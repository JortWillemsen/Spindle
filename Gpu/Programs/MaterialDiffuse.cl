// This kernel calculates the extension ray and shadow ray, following
// an incoming ray on a simple diffuse material. Also updates pixel color.

typedef struct
{
    float3 origin;
    float3 direction;
} Ray;

// RNG
uint xorshift32(uint* state) // Marsaglia’s xorshift32 (from slideset)
{
    uint v = *state;

    v ^= v << 13u;
    v ^= v >> 17u;
    v ^= v << 5u;

    *state = v;
    return v;
}

// TODO: might work better but triple the memory
uint3 pgc3d(uint3* state) // From Jarzynski and Olano, 2020. “Hash Functions for GPU Rendering”. JCGT.
{
    uint3 v = *state;

    v = v * 1664525u + 1013904223u;
    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;
    v ^= v >> 16u;
    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;

    *state = v;
    return v;
}

float RandomFloat(uint* state)
{
    return xorshift32(state) * 2.3283064365387e-10f;
}

// Based on lecture 8: variance reduction pt. 2
float3 CosineSampleHemisphere(float3 normal, uint* randomState)
{
    float r0 = RandomFloat(randomState), r1 = RandomFloat(randomState);
    float r = sqrt(r0);
    float theta = 2 * M_PI * r1;
    float x = r * cos(theta);
    float y = r * sin(theta);
    float z = sqrt(1 - r0);
    float3 randomVector = (float3)(x, y, z);

    // TODO: the part below has been generated by ChatGPT 4o mini, but discussed with teacher :)
    // Align the random vector with the given normal vector

    float3 tangent1, tangent2;

    // Create an orthogonal basis with the normal
    if (fabs(normal.x) > fabs(normal.y)) {
        tangent1 = normalize(cross((float3)(0, 1, 0), normal)); // use a world axis if normal is along x or z
    }
    else {
        tangent1 = normalize(cross((float3)(1, 0, 0), normal));
    }
    tangent2 = cross(normal, tangent1);

    // Now apply the transformation so that the original sample is aligned with he normal
    return randomVector.x * tangent1 + randomVector.y * tangent2 + randomVector.z * normal;
}

__kernel void scatter_diffuse(
    __global uint *randomStates,
    __global float3 *hitPositions,
    __global float3 *normals,
    __global const float *mat_albedos,
    __global const float3 *mat_colors,
    __global Ray *extensionRays,
    __global Ray *shadowRays,
    __global float3 *pixelColors,
    __global int *debugOutputs)
{
    uint x = get_global_id(0);
    uint y = get_global_id(1);
    uint i = x + y * get_global_size(0);

    // ==> Calculate extension ray

    float3 bounceDirection = CosineSampleHemisphere(normals[i], &randomStates[i]);
    Ray extensionRay; // TODO: does C allow to immediatly assign the fields within the array without declaring a new instance?
    extensionRay.origin = normals[i];
    extensionRay.direction = bounceDirection;
    extensionRays[i] = extensionRay;

    // ==> Calculate shadow ray

    // TODO we have never implemented this before
    
    // ==> Calculate sampled color

    pixelColors[i] *= mat_albedos[i] * mat_colors[i]; // Every sample the new color is weighed in
    // TODO assumes that if the ray hits nothing (skybox), the following is applied (ambient lighting):
    // float a = .5f * (dirNormalized.Y + 1f);
    // pixel = (1f - a) * new Vector3(1f, 1f, 1f) + a * new Vector3(.5f, .7f, 1f );

    debugOutputs[i] = extensionRays[i].direction[0];
}